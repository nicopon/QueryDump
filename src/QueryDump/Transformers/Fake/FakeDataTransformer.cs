using System.Text.RegularExpressions;
using Bogus;
using QueryDump.Core;
using QueryDump.Core.Options;

namespace QueryDump.Transformers.Fake;

/// <summary>
/// Transforms data rows by replacing specified columns with fake data generated by Bogus.
/// Supports column references using {{COLUMN_NAME}} syntax for composing values.
/// </summary>
public sealed partial class FakeDataTransformer : IDataTransformer, IRequiresOptions<FakeOptions>
{
    public int Priority => 30; // Faker runs after Null (10) and Overwrite (20)

    private readonly Dictionary<string, string> _mappings = new(StringComparer.OrdinalIgnoreCase);
    private readonly FakerRegistry _registry;
    private readonly Faker _faker;
    private readonly string _locale;
    
    // Deterministic mode fields
    private readonly string? _seedColumn;
    private readonly bool _deterministic;
    private int _seedColumnIndex = -1;
    private long _rowCounter = 0;  // For row-index-based deterministic mode
    
    // Paged Lazy Cache for deterministic mode
    private const int PAGE_SIZE = 1024;
    private Dictionary<int, PagedCache>? _pagedCaches;  // columnIndex -> cache
    
    // Regex to match {{COLUMN_NAME}} patterns - compiled once for performance
    [GeneratedRegex(@"\{\{([^}]+)\}\}", RegexOptions.Compiled)]
    private static partial Regex TemplatePattern();
    
    // State initialized in InitializeAsync - built once, reused for all rows
    private int[]? _generationOrder;  // Indices in order of generation (dependencies first)
    private ColumnProcessor[]? _processors;  // Pre-built processors for each column
    private Dictionary<string, int>? _columnNameToIndex;  // Fast lookup for template substitution
    private readonly List<string> _virtualColumns = [];  // Columns defined in --fake but not in query
    private int _realColumnCount;  // Number of real columns from query
    private IReadOnlyList<ColumnInfo>? _inputColumns;  // Store for building output schema

    public FakeDataTransformer(FakeOptions options)
    {
        _registry = new FakerRegistry();
        _locale = options.Locale;
        _seedColumn = options.SeedColumn;
        _deterministic = options.Deterministic;
        
        _faker = options.Seed.HasValue 
            ? new Faker(options.Locale) { Random = new Randomizer(options.Seed.Value) } 
            : new Faker(options.Locale);

        if (_deterministic && !string.IsNullOrEmpty(_seedColumn))
        {
            throw new ArgumentException("Options --fake-deterministic and --fake-seedcolumn cannot be used together.");
        }

        if (options.Mappings is not null)
        {
            foreach (var mapping in options.Mappings)
            {
                ParseMapping(mapping);
            }
        }
    }

    /// <summary>
    /// Indicates whether any column mappings are configured.
    /// </summary>
    public bool HasMappings => _mappings.Count > 0;

    /// <summary>
    /// Get the FakerRegistry for listing available fakers.
    /// </summary>
    public FakerRegistry Registry => _registry;

    public ValueTask<IReadOnlyList<ColumnInfo>> InitializeAsync(IReadOnlyList<ColumnInfo> columns, CancellationToken ct = default)
    {
        _inputColumns = columns;
        
        if (!HasMappings)
        {
            _processors = null;
            _generationOrder = null;
            return new ValueTask<IReadOnlyList<ColumnInfo>>(columns);
        }

        // Build column name to index map (once)
        _columnNameToIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        _realColumnCount = columns.Count;
        for (var i = 0; i < columns.Count; i++)
        {
            _columnNameToIndex[columns[i].Name] = i;
        }
        
        // Detect virtual columns: defined in --fake but not in query results
        _virtualColumns.Clear();
        foreach (var colName in _mappings.Keys)
        {
            if (!_columnNameToIndex.ContainsKey(colName))
            {
                // Virtual column: assign next available index
                var virtualIndex = _realColumnCount + _virtualColumns.Count;
                _columnNameToIndex[colName] = virtualIndex;
                _virtualColumns.Add(colName);
            }
        }
        
        var totalColumns = _realColumnCount + _virtualColumns.Count;

        // Build processors for each mapped column (real and virtual)
        _processors = new ColumnProcessor[totalColumns];
        var templateColumns = new List<int>();
        var nonTemplateColumns = new List<int>();

        // Process real columns
        for (var i = 0; i < columns.Count; i++)
        {
            var colName = columns[i].Name;
            
            if (!_mappings.TryGetValue(colName, out var fakerPath))
            {
                continue;
            }

            // Check if this is a template (contains {{...}})
            if (IsTemplate(fakerPath))
            {
                // Extract referenced column names for dependency checking
                var referencedColumns = ExtractReferencedColumns(fakerPath);
                _processors[i] = new ColumnProcessor(i, fakerPath, referencedColumns);
                templateColumns.Add(i);
            }
            else
            {
                // Regular faker or hardcoded string
                var generator = BuildGenerator(fakerPath, colName);
                _processors[i] = new ColumnProcessor(i, generator, fakerPath);
                nonTemplateColumns.Add(i);
            }
        }
        
        // Process virtual columns
        foreach (var virtualCol in _virtualColumns)
        {
            var virtualIndex = _columnNameToIndex[virtualCol];
            var fakerPath = _mappings[virtualCol];
            
            if (IsTemplate(fakerPath))
            {
                var referencedColumns = ExtractReferencedColumns(fakerPath);
                _processors[virtualIndex] = new ColumnProcessor(virtualIndex, fakerPath, referencedColumns);
                templateColumns.Add(virtualIndex);
            }
            else
            {
                var generator = BuildGenerator(fakerPath, virtualCol);
                _processors[virtualIndex] = new ColumnProcessor(virtualIndex, generator, fakerPath);
                nonTemplateColumns.Add(virtualIndex);
            }
        }

        // Build generation order: non-templates first, then templates
        _generationOrder = new int[nonTemplateColumns.Count + templateColumns.Count];
        var idx = 0;
        foreach (var col in nonTemplateColumns)
        {
            _generationOrder[idx++] = col;
        }
        foreach (var col in templateColumns)
        {
            _generationOrder[idx++] = col;
        }

        // Resolve seed column index if specified (for deterministic mode)
        if (_seedColumn is not null)
        {
            if (!_columnNameToIndex.TryGetValue(_seedColumn, out _seedColumnIndex))
            {
                throw new InvalidOperationException($"Seed column '{_seedColumn}' not found in result set.");
            }
        }

        // Initialize paged caches for deterministic mode
        if (_deterministic || _seedColumnIndex >= 0)
        {
            _pagedCaches = [];
            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (!processor.IsTemplate && processor.Generator is not null && processor.FakerPath is not null)
                {
                    _pagedCaches[colIdx] = new PagedCache(_locale, processor.Generator, processor.FakerHash);
                }
            }
        }

        // Build output schema: input columns + virtual columns
        var outputColumns = new List<ColumnInfo>(columns);
        foreach (var virtualCol in _virtualColumns)
        {
            outputColumns.Add(new ColumnInfo(virtualCol, typeof(string), true, IsVirtual: true));
        }
        
        return new ValueTask<IReadOnlyList<ColumnInfo>>(outputColumns);
    }

    public object?[] Transform(object?[] row)
    {
        if (_processors is null || _generationOrder is null)
        {
            return row;
        }

        // Row expansion
        object?[] workingRow = row;
        if (_virtualColumns.Count > 0)
        {
            var totalColumns = _realColumnCount + _virtualColumns.Count;
            if (row.Length < totalColumns)
            {
                workingRow = new object?[totalColumns];
                Array.Copy(row, workingRow, row.Length);
            }
        }

        if (_pagedCaches is not null)
        {
            // Paged Lazy Cache mode (deterministic)
            int cacheIndex;
            if (_seedColumnIndex >= 0)
            {
                // Based on column value
                var seedValue = workingRow[_seedColumnIndex];
                cacheIndex = unchecked((int)StableHash.Compute(seedValue));
            }
            else
            {
                // Based on row index
                cacheIndex = unchecked((int)_rowCounter);
                _rowCounter++;
            }

            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate)
                {
                    workingRow[colIdx] = SubstituteTemplate(processor.Template!, workingRow);
                }
                else if (_pagedCaches.TryGetValue(colIdx, out var cache))
                {
                    workingRow[colIdx] = cache.GetValue(cacheIndex);
                }
                else if (processor.Generator is not null)
                {
                    // Fallback (e.g. hardcoded strings)
                    workingRow[colIdx] = processor.Generator(_faker);
                }
            }
        }
        else
        {
            // Non-deterministic mode (Standard Random)
            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate)
                {
                    workingRow[colIdx] = SubstituteTemplate(processor.Template!, workingRow);
                }
                else if (processor.Generator is not null)
                {
                    workingRow[colIdx] = processor.Generator(_faker);
                }
            }
        }

        return workingRow;
    }

    private static bool IsTemplate(string value) => value.Contains("{{");

    private static HashSet<string> ExtractReferencedColumns(string template)
    {
        var matches = TemplatePattern().Matches(template);
        var result = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private string SubstituteTemplate(string template, object?[] row)
    {
        return TemplatePattern().Replace(template, match =>
        {
            var colName = match.Groups[1].Value;
            if (_columnNameToIndex!.TryGetValue(colName, out var idx))
            {
                return row[idx]?.ToString() ?? string.Empty;
            }
            // Column not found - keep original placeholder with warning logged once during init
            return match.Value;
        });
    }

    private Func<Faker, object?>? BuildGenerator(string fakerPath, string colName)
    {
        // Extract variant suffix (#xxx) if present
        var hashIndex = fakerPath.IndexOf('#');
        var basePath = hashIndex >= 0 ? fakerPath[..hashIndex] : fakerPath;
        
        var generator = _registry.GetGenerator(basePath.ToLowerInvariant());
        
        if (generator is not null)
        {
            return generator;
        }

        // Check if it was supposed to be a faker (valid dataset)
        var parts = basePath.Split('.', 2);
        var dataset = parts.Length > 0 ? parts[0] : "";
        
        if (_registry.HasDataset(dataset))
        {
            throw new InvalidOperationException($"Unknown faker method '{basePath}' for column '{colName}'. Use --fake-list to see available options.");
        }

        // Hardcoded string fallback (return full path including variant)
        return _ => fakerPath;
    }

    private void ParseMapping(string mapping)
    {
        // Format: COLUMN:dataset.method or COLUMN:{{OTHER_COLUMN}} template
        var separatorIndex = mapping.IndexOf(':');
        if (separatorIndex <= 0 || separatorIndex >= mapping.Length - 1)
        {
            Console.Error.WriteLine($"Warning: Invalid mapping format '{mapping}'. Expected 'COLUMN:value'");
            return;
        }

        var column = mapping[..separatorIndex].Trim();
        var value = mapping[(separatorIndex + 1)..].Trim();

        if (string.IsNullOrEmpty(column) || string.IsNullOrEmpty(value))
        {
            Console.Error.WriteLine($"Warning: Invalid mapping '{mapping}'. Column and value cannot be empty.");
            return;
        }

        // For templates, store as-is
        if (IsTemplate(value))
        {
            _mappings[column] = value;
            return;
        }

        // For fakers/strings, apply existing validation logic
        // Extract variant suffix (#xxx) if present - used for same-faker different values
        var hashIndex = value.IndexOf('#');
        var baseFakerPath = hashIndex >= 0 ? value[..hashIndex] : value;
        var variant = hashIndex >= 0 ? value[(hashIndex + 1)..] : null;
        
        var parts = baseFakerPath.Split('.', 2);
        var datasetName = parts.Length > 0 ? parts[0] : string.Empty;

        if (_registry.HasDataset(datasetName))
        {
            if (!_registry.HasGenerator(baseFakerPath))
            {
                throw new InvalidOperationException($"Unknown faker method '{baseFakerPath}' for dataset '{datasetName}'. Use --fake-list to see available options.");
            }
            // Store full path including variant for distinct hashing
            _mappings[column] = value;
        }
        else if (value.Contains(':'))
        {
             // Fallback: User might have used colon instead of dot (e.g. "finance:iban")
             var normalized = baseFakerPath.Replace(':', '.');
             if (_registry.HasGenerator(normalized))
             {
                 // Keep variant if present
                 _mappings[column] = variant is not null ? $"{normalized}#{variant}" : normalized;
             }
             else
             {
                 // Not a known faker even after normalization, treat as string
                 _mappings[column] = value;
             }
        }
        else
        {
            // Hardcoded string
            _mappings[column] = value;
        }
    }

    /// <summary>
    /// Holds pre-computed processing info for a column.
    /// </summary>
    private readonly struct ColumnProcessor
    {
        public readonly int Index;
        public readonly Func<Faker, object?>? Generator;
        public readonly string? Template;
        public readonly HashSet<string>? ReferencedColumns;
        public readonly string? FakerPath; // For deterministic mode hashing
        public readonly uint FakerHash; // Precomputed hash

        public bool IsTemplate => Template is not null;

        // Constructor for faker/hardcoded
        public ColumnProcessor(int index, Func<Faker, object?>? generator, string? fakerPath = null)
        {
            Index = index;
            Generator = generator;
            Template = null;
            ReferencedColumns = null;
            FakerPath = fakerPath;
            FakerHash = fakerPath is not null ? StableHash.ComputeFromString(fakerPath) : 0;
        }

        // Constructor for template
        public ColumnProcessor(int index, string template, HashSet<string> referencedColumns)
        {
            Index = index;
            Generator = null;
            Template = template;
            ReferencedColumns = referencedColumns;
            FakerPath = null;
            FakerHash = 0;
        }
    }

    /// <summary>
    /// Lazily-populated paged cache for deterministic fake data generation.
    /// Pages are generated on-demand to minimize Randomizer instantiation overhead.
    /// </summary>
    private sealed class PagedCache(string locale, Func<Faker, object?> generator, uint fakerHash)
    {
        private readonly string _locale = locale;
        private readonly Func<Faker, object?> _generator = generator;
        private readonly uint _fakerHash = fakerHash;
        private readonly Dictionary<int, object?[]> _pages = [];

        public object? GetValue(int index)
        {
            // Apply modulo to limit total cached values (e.g., 64 pages × 1024 = 65536 values)
            // This bounds memory while maintaining determinism (same index → same value)
            const int MAX_CACHED_VALUES = 65536;
            var boundedIndex = ((index % MAX_CACHED_VALUES) + MAX_CACHED_VALUES) % MAX_CACHED_VALUES;
            
            var pageIndex = boundedIndex / PAGE_SIZE;
            var offset = boundedIndex % PAGE_SIZE;

            if (!_pages.TryGetValue(pageIndex, out var page))
            {
                page = GeneratePage(pageIndex);
                _pages[pageIndex] = page;
            }

            return page[offset];
        }

        private object?[] GeneratePage(int pageIndex)
        {
            // Compute a deterministic seed for this page
            // Combine fakerHash + pageIndex to ensure different pages have different seeds
            var pageSeed = unchecked((int)(_fakerHash + (uint)pageIndex * 397));
            
            var faker = new Faker(_locale) { Random = new Randomizer(pageSeed) };
            var page = new object?[PAGE_SIZE];
            
            for (int i = 0; i < PAGE_SIZE; i++)
            {
                page[i] = _generator(faker);
            }
            
            return page;
        }
    }
}
