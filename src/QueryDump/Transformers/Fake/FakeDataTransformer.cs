using System.Text.RegularExpressions;
using Bogus;
using QueryDump.Core;
using QueryDump.Core.Options;

namespace QueryDump.Transformers.Fake;

/// <summary>
/// Transforms data rows by replacing specified columns with fake data generated by Bogus.
/// Supports column references using {{COLUMN_NAME}} syntax for composing values.
/// </summary>
public sealed partial class FakeDataTransformer : IDataTransformer, IRequiresOptions<FakeOptions>
{
    public int Priority => 30; // Faker runs after Null (10) and Static (20)

    private readonly Dictionary<string, string> _mappings = new(StringComparer.OrdinalIgnoreCase);
    private readonly FakerRegistry _registry;
    private readonly Faker _faker;
    private readonly string _locale;
    
    // Deterministic mode fields
    private readonly string? _seedColumn;
    private readonly int _tableSize;
    private readonly bool _deterministic;
    private int _seedColumnIndex = -1;
    private long _rowCounter = 0;  // For row-index-based deterministic mode
    private Dictionary<int, object?[]>? _precomputedTables;
    
    // Regex to match {{COLUMN_NAME}} patterns - compiled once for performance
    [GeneratedRegex(@"\{\{([^}]+)\}\}", RegexOptions.Compiled)]
    private static partial Regex TemplatePattern();
    
    // State initialized in InitializeAsync - built once, reused for all rows
    private int[]? _generationOrder;  // Indices in order of generation (dependencies first)
    private ColumnProcessor[]? _processors;  // Pre-built processors for each column
    private Dictionary<string, int>? _columnNameToIndex;  // Fast lookup for template substitution
    private List<string> _virtualColumns = new();  // Columns defined in --fake but not in query
    private int _realColumnCount;  // Number of real columns from query
    private IReadOnlyList<ColumnInfo>? _inputColumns;  // Store for building output schema

    public FakeDataTransformer(FakeOptions options)
    {
        _registry = new FakerRegistry();
        _locale = options.Locale;
        _seedColumn = options.SeedColumn;
        _tableSize = options.TableSize;
        _deterministic = options.Deterministic;
        
        _faker = options.Seed.HasValue 
            ? new Faker(options.Locale) { Random = new Randomizer(options.Seed.Value) } 
            : new Faker(options.Locale);

        if (_deterministic && !string.IsNullOrEmpty(_seedColumn))
        {
            throw new ArgumentException("Options --fake-deterministic and --fake-seedcolumn cannot be used together.");
        }

        if (options.Mappings is not null)
        {
            foreach (var mapping in options.Mappings)
            {
                ParseMapping(mapping);
            }
        }
    }

    /// <summary>
    /// Indicates whether any column mappings are configured.
    /// </summary>
    public bool HasMappings => _mappings.Count > 0;

    /// <summary>
    /// Get the FakerRegistry for listing available fakers.
    /// </summary>
    public FakerRegistry Registry => _registry;

    public ValueTask<IReadOnlyList<ColumnInfo>> InitializeAsync(IReadOnlyList<ColumnInfo> columns, CancellationToken ct = default)
    {
        _inputColumns = columns;
        
        if (!HasMappings)
        {
            _processors = null;
            _generationOrder = null;
            return new ValueTask<IReadOnlyList<ColumnInfo>>(columns);
        }

        // Build column name to index map (once)
        _columnNameToIndex = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
        _realColumnCount = columns.Count;
        for (var i = 0; i < columns.Count; i++)
        {
            _columnNameToIndex[columns[i].Name] = i;
        }
        
        // Detect virtual columns: defined in --fake but not in query results
        _virtualColumns.Clear();
        foreach (var colName in _mappings.Keys)
        {
            if (!_columnNameToIndex.ContainsKey(colName))
            {
                // Virtual column: assign next available index
                var virtualIndex = _realColumnCount + _virtualColumns.Count;
                _columnNameToIndex[colName] = virtualIndex;
                _virtualColumns.Add(colName);
            }
        }
        
        var totalColumns = _realColumnCount + _virtualColumns.Count;

        // Build processors for each mapped column (real and virtual)
        _processors = new ColumnProcessor[totalColumns];
        var templateColumns = new List<int>();
        var nonTemplateColumns = new List<int>();

        // Process real columns
        for (var i = 0; i < columns.Count; i++)
        {
            var colName = columns[i].Name;
            
            if (!_mappings.TryGetValue(colName, out var fakerPath))
            {
                continue;
            }

            // Check if this is a template (contains {{...}})
            if (IsTemplate(fakerPath))
            {
                // Extract referenced column names for dependency checking
                var referencedColumns = ExtractReferencedColumns(fakerPath);
                _processors[i] = new ColumnProcessor(i, fakerPath, referencedColumns);
                templateColumns.Add(i);
            }
            else
            {
                // Regular faker or hardcoded string
                var generator = BuildGenerator(fakerPath, colName);
                _processors[i] = new ColumnProcessor(i, generator, fakerPath);
                nonTemplateColumns.Add(i);
            }
        }
        
        // Process virtual columns
        foreach (var virtualCol in _virtualColumns)
        {
            var virtualIndex = _columnNameToIndex[virtualCol];
            var fakerPath = _mappings[virtualCol];
            
            if (IsTemplate(fakerPath))
            {
                var referencedColumns = ExtractReferencedColumns(fakerPath);
                _processors[virtualIndex] = new ColumnProcessor(virtualIndex, fakerPath, referencedColumns);
                templateColumns.Add(virtualIndex);
            }
            else
            {
                var generator = BuildGenerator(fakerPath, virtualCol);
                _processors[virtualIndex] = new ColumnProcessor(virtualIndex, generator, fakerPath);
                nonTemplateColumns.Add(virtualIndex);
            }
        }

        // Build generation order: non-templates first, then templates
        // For now, simple ordering. Future: topological sort for nested templates
        _generationOrder = new int[nonTemplateColumns.Count + templateColumns.Count];
        var idx = 0;
        foreach (var col in nonTemplateColumns)
        {
            _generationOrder[idx++] = col;
        }
        foreach (var col in templateColumns)
        {
            _generationOrder[idx++] = col;
        }

        // Precompute tables for deterministic mode (seed column OR deterministic flag)
        if (_seedColumn is not null || _deterministic)
        {
            // Resolve seed column index if specified
            if (_seedColumn is not null)
            {
                if (!_columnNameToIndex.TryGetValue(_seedColumn, out _seedColumnIndex))
                {
                    throw new InvalidOperationException($"Seed column '{_seedColumn}' not found in result set.");
                }
            }
            // else: _seedColumnIndex stays -1, will use row counter
            
            _precomputedTables = new Dictionary<int, object?[]>();
            
            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate || processor.Generator is null || processor.FakerPath is null)
                {
                    continue; // Skip templates and hardcoded strings
                }
                
                // Hash stable du faker path - garantit coh√©rence entre runs
                var fakerHash = StableHash.ComputeFromString(processor.FakerPath);
                
                var table = new object?[_tableSize];
                var tempFaker = new Faker(_locale);
                for (int i = 0; i < _tableSize; i++)
                {
                    var seed = unchecked((int)(fakerHash + (uint)i));
                    tempFaker.Random = new Randomizer(seed);
                    table[i] = processor.Generator(tempFaker);
                }
                _precomputedTables[colIdx] = table;
            }
        }

        // Build output schema: input columns + virtual columns
        var outputColumns = new List<ColumnInfo>(columns);
        foreach (var virtualCol in _virtualColumns)
        {
            outputColumns.Add(new ColumnInfo(virtualCol, typeof(string), true, IsVirtual: true));
        }
        
        return new ValueTask<IReadOnlyList<ColumnInfo>>(outputColumns);
    }

    public object?[] Transform(object?[] row)
    {
        if (_processors is null || _generationOrder is null)
        {
            return row;
        }

        // Row expansion
        object?[] workingRow = row;
        if (_virtualColumns.Count > 0)
        {
            var totalColumns = _realColumnCount + _virtualColumns.Count;
            if (row.Length < totalColumns)
            {
                workingRow = new object?[totalColumns];
                Array.Copy(row, workingRow, row.Length);
            }
        }

        if (_precomputedTables is not null)
        {
            int tableIndex;
            if (_seedColumnIndex >= 0)
            {
                // Seed column mode: hash the column value
                var seedValue = workingRow[_seedColumnIndex];
                var hash = StableHash.Compute(seedValue);
                tableIndex = (int)(hash % (uint)_tableSize);
            }
            else
            {
                // Row-index mode: use row counter directly
                tableIndex = (int)(_rowCounter % (uint)_tableSize);
                _rowCounter++;
            }

            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate)
                {
                    workingRow[colIdx] = SubstituteTemplate(processor.Template!, workingRow);
                }
                else if (_precomputedTables.TryGetValue(colIdx, out var table))
                {
                     // Deterministic lookup
                     workingRow[colIdx] = table[tableIndex];
                }
                else if (processor.Generator is not null)
                {
                    // Hardcoded string (no table)
                    workingRow[colIdx] = processor.Generator(_faker!);
                }
            }
        }
        else
        {
            // Non-deterministic mode
            foreach (var colIdx in _generationOrder)
            {
                var processor = _processors[colIdx];
                if (processor.IsTemplate)
                {
                    workingRow[colIdx] = SubstituteTemplate(processor.Template!, workingRow);
                }
                else if (processor.Generator is not null)
                {
                    workingRow[colIdx] = processor.Generator(_faker!);
                }
            }
        }

        return workingRow;
    }

    private static bool IsTemplate(string value) => value.Contains("{{");

    private static HashSet<string> ExtractReferencedColumns(string template)
    {
        var matches = TemplatePattern().Matches(template);
        var result = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (Match match in matches)
        {
            result.Add(match.Groups[1].Value);
        }
        return result;
    }

    private string SubstituteTemplate(string template, object?[] row)
    {
        return TemplatePattern().Replace(template, match =>
        {
            var colName = match.Groups[1].Value;
            if (_columnNameToIndex!.TryGetValue(colName, out var idx))
            {
                return row[idx]?.ToString() ?? string.Empty;
            }
            // Column not found - keep original placeholder with warning logged once during init
            return match.Value;
        });
    }

    private Func<Faker, object?>? BuildGenerator(string fakerPath, string colName)
    {
        // Extract variant suffix (#xxx) if present
        var hashIndex = fakerPath.IndexOf('#');
        var basePath = hashIndex >= 0 ? fakerPath[..hashIndex] : fakerPath;
        
        var generator = _registry.GetGenerator(basePath.ToLowerInvariant());
        
        if (generator is not null)
        {
            return generator;
        }

        // Check if it was supposed to be a faker (valid dataset)
        var parts = basePath.Split('.', 2);
        var dataset = parts.Length > 0 ? parts[0] : "";
        
        if (_registry.HasDataset(dataset))
        {
            throw new InvalidOperationException($"Unknown faker method '{basePath}' for column '{colName}'. Use --fake-list to see available options.");
        }

        // Hardcoded string fallback (return full path including variant)
        return _ => fakerPath;
    }

    private void ParseMapping(string mapping)
    {
        // Format: COLUMN:dataset.method or COLUMN:{{OTHER_COLUMN}} template
        var separatorIndex = mapping.IndexOf(':');
        if (separatorIndex <= 0 || separatorIndex >= mapping.Length - 1)
        {
            Console.Error.WriteLine($"Warning: Invalid mapping format '{mapping}'. Expected 'COLUMN:value'");
            return;
        }

        var column = mapping[..separatorIndex].Trim();
        var value = mapping[(separatorIndex + 1)..].Trim();

        if (string.IsNullOrEmpty(column) || string.IsNullOrEmpty(value))
        {
            Console.Error.WriteLine($"Warning: Invalid mapping '{mapping}'. Column and value cannot be empty.");
            return;
        }

        // For templates, store as-is
        if (IsTemplate(value))
        {
            _mappings[column] = value;
            return;
        }

        // For fakers/strings, apply existing validation logic
        // Extract variant suffix (#xxx) if present - used for same-faker different values
        var hashIndex = value.IndexOf('#');
        var baseFakerPath = hashIndex >= 0 ? value[..hashIndex] : value;
        var variant = hashIndex >= 0 ? value[(hashIndex + 1)..] : null;
        
        var parts = baseFakerPath.Split('.', 2);
        var datasetName = parts.Length > 0 ? parts[0] : string.Empty;

        if (_registry.HasDataset(datasetName))
        {
            if (!_registry.HasGenerator(baseFakerPath))
            {
                throw new InvalidOperationException($"Unknown faker method '{baseFakerPath}' for dataset '{datasetName}'. Use --fake-list to see available options.");
            }
            // Store full path including variant for distinct hashing
            _mappings[column] = value;
        }
        else if (value.Contains(':'))
        {
             // Fallback: User might have used colon instead of dot (e.g. "finance:iban")
             var normalized = baseFakerPath.Replace(':', '.');
             if (_registry.HasGenerator(normalized))
             {
                 // Keep variant if present
                 _mappings[column] = variant is not null ? $"{normalized}#{variant}" : normalized;
             }
             else
             {
                 // Not a known faker even after normalization, treat as string
                 _mappings[column] = value;
             }
        }
        else
        {
            // Hardcoded string
            _mappings[column] = value;
        }
    }

    /// <summary>
    /// Holds pre-computed processing info for a column.
    /// </summary>
    private readonly struct ColumnProcessor
    {
        public readonly int Index;
        public readonly Func<Faker, object?>? Generator;
        public readonly string? Template;
        public readonly HashSet<string>? ReferencedColumns;
        public readonly string? FakerPath; // For deterministic mode hashing

        public bool IsTemplate => Template is not null;

        // Constructor for faker/hardcoded
        public ColumnProcessor(int index, Func<Faker, object?>? generator, string? fakerPath = null)
        {
            Index = index;
            Generator = generator;
            Template = null;
            ReferencedColumns = null;
            FakerPath = fakerPath;
        }

        // Constructor for template
        public ColumnProcessor(int index, string template, HashSet<string> referencedColumns)
        {
            Index = index;
            Generator = null;
            Template = template;
            ReferencedColumns = referencedColumns;
            FakerPath = null;
        }
    }
}

